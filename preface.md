# Preface

## What is Tidy First?

Software design is an exercise in human relationships, starting with ourselves.

Why don't we take time to care for ourselves? Take time to make our work easier? Why do we go down the rabbit hole of cleaning code to the exclusion of work that would help our users?

Tidy First is the first step to take when faced wth messy code. Software design is a powerful tool to ease pain in the world - if it is used well.  Used badly, it's another instrument of oppression and a drag on effectiveness of software development.

Tidy First is the first of a series of books focusing on software design.

## Audience

Programmers, lead developers, hands-on software architects, and technical managers.

## What You Will Learn

### You will understand:

* The difference between changes to the behavior of a system and changes to its structure.
* The enabling magic of alternating investment in structure and behavior - as a lone programmer changing code.
* The basics of the theory of how software design works and the forces that act on it.

### You will be able to:

* Improve your own experience programming by sometimes tidying first (and sometimes tidying after).
* Begin to make large changes in small, safe steps.
* Prepare to design as a human activity with diverging incentives.

## Structure of the Book

1. Introduction
2. Tidyings
3. Managing
4. Theory

## Why Empirical Software Design?

_**When**_ should we do design?

### Speculative Design

We know what we want to do next, so let's design for it today. It will be cheaper to design now. Besides, once the software is in production, we ill never the chance to design. Let's pile all in today.

### Reactive Design

Features are all anyone cares about, so let's design as little as we can today so we can get back to features.  Only when features become nearly impossible to add will we begrudgingly improve the design, and then only just enough to get back to features.

### Empirical Design

Somewhere in the middle of Speculative & Reactive.&#x20;

When we **observe** that a certain class of features is hard to add, we design until the pressure is relieved.  Start with just enough design to get the feedback cycles going.  When using empirical software design, the question of when is contingent on what we observe and experience

> Empirical Definition: "Based on, concerned with, or verifiable by observation or experience rather than theory or pure logic"

